# HTMS ğŸ’¨ Stream Async HTML, Stay SEO-Friendly

> **"What if async content didnâ€™t nuke your SEO?"**
>
> *(HTML streaming: ancient wisdom, modern awakening, progressive enhancementâ„¢.)*

HTMS is the absurdly simple answer to a dumbly persistent problem:
you want async content that shows up progressively, and you want search engines to actually see it.

**HTMS does both.** It streams HTML fragments as theyâ€™re ready, wraps them in tiny self-cleaning WebComponents, and
makes
sure the whole thing lands in the very first HTTP response. No hydration, no React-like ceremony, no SEO tax. Just async
HTML that behaves likeâ€¦ HTML.

[![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white)](https://developer.mozilla.org/en-US/docs/Web/HTML)
[![Streaming](https://img.shields.io/badge/streaming-ğŸ’¨-blue?style=for-the-badge)](https://github.com/skarab42/htms)
[![License](https://img.shields.io/badge/license-MIT-blue.svg?style=for-the-badge)](license.md)
[![Crates.io](https://img.shields.io/crates/v/htms.svg?style=for-the-badge&logo=rust)](https://crates.io/crates/htms)

> ğŸŸ¨ JavaScript dev? Check out [**htms-js**](https://github.com/skarab42/htms-js)

---

## âš¡ The 30-Second Demo

HTMS is primarily about **streaming HTML**. The core idea? Bind HTML `data-htms` attributes to auto-generated async
methods that progressively replace content. Here's how it looks:

Write normal HTML with `data-htms` attributes:

```html
<header>Static content loads instantly</header>
<div data-htms="fn:breaking_news">Loading news...</div>
<div data-htms="fn:user_dashboard">Loading dashboard...</div>
<footer>Static content loads instantly</footer>
```

Write normal Rust async functions:

```rust
use htms::Template;

#[derive(Template)]
#[template = "page.html"]
pub struct HomePage;

// The `HomePageRender` trait is auto generated by the derive macro
impl HomePageRender for HomePage {
    async fn breaking_news_task() -> String {
        // Some API call - takes 2 seconds
        fetch_latest_news().await
    }

    async fn user_dashboard_task() -> String {
        // Heavy computation - takes 5 seconds
        generate_user_analytics().await
    }
}
```

Stream it all in one request with your favorite backend, here with [Axum](https://github.com/tokio-rs/axum) and our
adapter:

```rust
use htms::axum::HtmlStream;

async fn home_page_handler() -> Response {
    let stream = HomePage::default().render();

    HtmlStream::from(stream).into_response()
}
```

**Result:** Your page appears instantly with static content, then sections fill in progressively as async tasks
complete. All content is SEO-visible in the initial HTTP response.

---

## ğŸ’» Try the live demo

- https://htms.skarab42.dev

![](images/htms-dashboard-demo.gif "htms dashboard demo")

```bash
cargo run -p demo --example dashboard
# Visit http://localhost:3000 and watch the magic
```

## ğŸ§  How It Actually Works

The â€œmagicâ€ isnâ€™t magic at all â€” itâ€™s just **one boring HTTP response, streamed in chunks**:

1. **Instant paint**: The browser gets real static HTML immediately, no waiting room.
2. **Async chunks**: Slow stuff (APIs, DB crunching, AI hallucinationsâ€¦) arrives later, wrapped in `<htms-chunk>` tags
   inside the same stream.
3. **Self-cleaning swap**: Each `<htms-chunk>` runs a [microscopic](crates/core/src/static/htms_chunk.js) JS snippet
   that swaps the placeholder with the real thing, then yeets itself out of the DOM.
4. **SEO jackpot**: Because itâ€™s all part of the original response body, search engines see the full page â€” async
   content included.

**No hydration. No virtual DOM.** Just HTML showing up as itâ€™s ready, like the web has always pretended to work.

## ğŸ˜‰ The "Trust Me Bro" Comparison Chart

| Feature              | HTMS ğŸ’¨                       | Traditional SPA         | SSR + Hydration               |
|----------------------|-------------------------------|-------------------------|-------------------------------|
| **First Paint**      | ğŸŸ¢ Instant (real HTML)        | ğŸ”´ Slow (JS boot)       | ğŸŸ¢ Fast                       |
| **SEO**              | ğŸŸ¢ Perfect (all in response)  | ğŸ”´ Needs hacks          | ğŸŸ¢ Good but complex           |
| **Progressive Load** | ğŸŸ¢ Native streaming           | ğŸŸ¢ Possible (XHR/fetch) | ğŸ”´ Not really                 |
| **Complexity**       | ğŸŸ¢ Low (HTML)                 | ğŸ”´ High (framework tax) | ğŸ”´ Very high (double work)    |
| **JS Required**      | ğŸŸ¢ Minimal (self-cleaning WC) | ğŸ”´ Heavy bundle         | ğŸ”´ Heavy bundle               |
| **Developer Vibes**  | ğŸŸ¢ â€œWait, thatâ€™s it?â€         | ğŸ”´ â€œWhereâ€™s my state?â€  | ğŸ”´ â€œWhy am I hydrating HTML?â€ |

## âš ï¸ The Fine Print (AKA Reality Check)

**HTMS is experimental AF.** ğŸ§ª

This project started as "hold up, HTML streaming has been a thing since the late 90s, and nobody talks about it?! Time
to
experiment" and spiraled into a full-blown rabbit hole of Rust learning and web development philosophy. The starting
point of this journey was [this
article](https://frontendmasters.com/blog/streaming-html/) by Chris Coyier.

### ğŸ¯ What This Really Is:

- A **learning playground** where I'm leveling up my Rust skills
- An **experiment** in making web development more enjoyable
- A **proof of concept** that streaming HTML doesn't have to suck
- Definitely **NOT production ready** (yet?)

### ğŸ¢ What to Expect:

- **~~Rapid~~ iteration** - things might change dramatically between versions or not at all
- **Breaking changes** - semantic versioning is more like... semantic suggestions
- **Rough edges** - some features are held together with digital duct tape
- **Fun surprises** - new features might appear overnight (or disappear)

### ğŸ¤· The Honest Truth:

I'm having way too much fun building this to promise anything stable. Use it, break it, contribute to it, but maybe
don't bet your startup on it just yet.

**But hey,** if you're as curious about the future of HTML streaming as I am, welcome aboard this beautiful mess! ğŸš€

## ğŸ’¡ Ideas / Maybe Planned

Some features Iâ€™m thinking about experimenting with:

* **Lazy-load compiled templates** â†’ right now everything is baked into the binary.
* **Some configuration options**: e.g. define a root path for templates via an environment variable (currently resolved
  from `CARGO_MANIFEST_DIR`).
* **More `data-htms` modifiers**:
    * `fn:` â†’ bind an async Rust function (already supported)
    * `include:` â†’ include another file in the template (already supported)
    * `wrap:` â†’ wrap a template inside another with a `<slot/>` system
    * `stream:` â†’ stream a list of HTML fragment into a target container
* **DOM injection helpers**: ergonomic APIs/modifiers for where the streamed content lands:
    * `replace` (default), `append`, `prepend`, `before`, `after`
    * Optional `selector:` to target a child node inside the placeholder
* **Cache system** for async fragments (avoid recomputing heavy tasks).
* **Error boundaries**: gracefully handle and display partial errors in chunks.
* **Integrations**: helper adapters for frameworks (Actix, Warp, Poem, etc.) (Axum is already supported).

Nothing guaranteed, just a playground of ideas. Contributions and experiments welcome ğŸš€

**Have an idea or found a gap?** [Open an issue](https://github.com/skarab42/htms/issues/new/choose)

---

*Disclaimer: Readme and docs written by human + AI. We're still debating who did the heavy lifting.* ğŸ¤–âœï¸
